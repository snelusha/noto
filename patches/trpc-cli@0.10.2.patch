diff --git a/node_modules/trpc-cli/.bun-tag-f7d589ce6c20d79a b/.bun-tag-f7d589ce6c20d79a
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
diff --git a/dist/index.js b/dist/index.js
index a190db0cf7bc87d196237e26397fd502596696ae..f8749b7fd545b08318cf323e87a51aaafca9940f 100644
--- a/dist/index.js
+++ b/dist/index.js
@@ -1,42 +1,77 @@
 "use strict";
-var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
-    if (k2 === undefined) k2 = k;
-    var desc = Object.getOwnPropertyDescriptor(m, k);
-    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
-      desc = { enumerable: true, get: function() { return m[k]; } };
-    }
-    Object.defineProperty(o, k2, desc);
-}) : (function(o, m, k, k2) {
-    if (k2 === undefined) k2 = k;
-    o[k2] = m[k];
-}));
-var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
-    Object.defineProperty(o, "default", { enumerable: true, value: v });
-}) : function(o, v) {
-    o["default"] = v;
-});
-var __importStar = (this && this.__importStar) || (function () {
-    var ownKeys = function(o) {
-        ownKeys = Object.getOwnPropertyNames || function (o) {
-            var ar = [];
-            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
-            return ar;
+var __createBinding =
+  (this && this.__createBinding) ||
+  (Object.create
+    ? function (o, m, k, k2) {
+        if (k2 === undefined) k2 = k;
+        var desc = Object.getOwnPropertyDescriptor(m, k);
+        if (
+          !desc ||
+          ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)
+        ) {
+          desc = {
+            enumerable: true,
+            get: function () {
+              return m[k];
+            },
+          };
+        }
+        Object.defineProperty(o, k2, desc);
+      }
+    : function (o, m, k, k2) {
+        if (k2 === undefined) k2 = k;
+        o[k2] = m[k];
+      });
+var __setModuleDefault =
+  (this && this.__setModuleDefault) ||
+  (Object.create
+    ? function (o, v) {
+        Object.defineProperty(o, "default", { enumerable: true, value: v });
+      }
+    : function (o, v) {
+        o["default"] = v;
+      });
+var __importStar =
+  (this && this.__importStar) ||
+  (function () {
+    var ownKeys = function (o) {
+      ownKeys =
+        Object.getOwnPropertyNames ||
+        function (o) {
+          var ar = [];
+          for (var k in o)
+            if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
+          return ar;
         };
-        return ownKeys(o);
+      return ownKeys(o);
     };
     return function (mod) {
-        if (mod && mod.__esModule) return mod;
-        var result = {};
-        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
-        __setModuleDefault(result, mod);
-        return result;
+      if (mod && mod.__esModule) return mod;
+      var result = {};
+      if (mod != null)
+        for (var k = ownKeys(mod), i = 0; i < k.length; i++)
+          if (k[i] !== "default") __createBinding(result, mod, k[i]);
+      __setModuleDefault(result, mod);
+      return result;
     };
-})();
-var __exportStar = (this && this.__exportStar) || function(m, exports) {
-    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
-};
+  })();
+var __exportStar =
+  (this && this.__exportStar) ||
+  function (m, exports) {
+    for (var p in m)
+      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p))
+        __createBinding(exports, m, p);
+  };
 Object.defineProperty(exports, "__esModule", { value: true });
-exports.CliValidationError = exports.FailedToExitError = exports.trpcCli = exports.parseRouter = exports.Command = exports.trpcServer = exports.zod = exports.z = void 0;
+exports.CliValidationError =
+  exports.FailedToExitError =
+  exports.trpcCli =
+  exports.parseRouter =
+  exports.Command =
+  exports.trpcServer =
+  exports.zod =
+  exports.z =
+    void 0;
 exports.createCli = createCli;
 /* eslint-disable @typescript-eslint/no-unsafe-assignment */
 const trpcServer11 = __importStar(require("@trpc/server"));
@@ -55,15 +90,20 @@ const trpc_compat_1 = require("./trpc-compat");
 const util_2 = require("./util");
 __exportStar(require("./types"), exports);
 var v4_1 = require("zod/v4");
-Object.defineProperty(exports, "z", { enumerable: true, get: function () { return v4_1.z; } });
+Object.defineProperty(exports, "z", {
+  enumerable: true,
+  get: function () {
+    return v4_1.z;
+  },
+});
 exports.zod = __importStar(require("zod"));
 exports.trpcServer = __importStar(require("@trpc/server"));
 class Command extends commander_1.Command {
-    /** @internal track the commands that have been run, so that we can find the `__result` of the last command */
-    __ran = [];
-    __input;
-    /** @internal stash the return value of the underlying procedure on the command so to pass to `FailedToExitError` for use in a pinch */
-    __result;
+  /** @internal track the commands that have been run, so that we can find the `__result` of the last command */
+  __ran = [];
+  __input;
+  /** @internal stash the return value of the underlying procedure on the command so to pass to `FailedToExitError` for use in a pinch */
+  __result;
 }
 exports.Command = Command;
 /**
@@ -72,83 +112,144 @@ exports.Command = Command;
  */
 // todo: maybe refactor to remove CLI-specific concepts like "positional parameters" and "options". Libraries like trpc-ui want to do basically the same thing, but here we handle lots more validation libraries and edge cases. We could share.
 const parseRouter = ({ router, ...params }) => {
-    if ((0, trpc_compat_1.isOrpcRouter)(router))
-        return parseOrpcRouter({ router, ...params });
-    return parseTrpcRouter({ router, ...params });
+  if ((0, trpc_compat_1.isOrpcRouter)(router))
+    return parseOrpcRouter({ router, ...params });
+  return parseTrpcRouter({ router, ...params });
 };
 exports.parseRouter = parseRouter;
 const parseTrpcRouter = ({ router, ...params }) => {
-    const defEntries = Object.entries(router._def.procedures);
-    return defEntries.map(([procedurePath, procedure]) => {
-        const meta = getMeta(procedure);
-        if (meta.jsonInput) {
-            return [procedurePath, { meta, parsedProcedure: jsonProcedureInputs(), incompatiblePairs: [], procedure }];
-        }
-        const procedureInputsResult = (0, parse_procedure_1.parseProcedureInputs)(procedure._def.inputs, params);
-        if (!procedureInputsResult.success) {
-            const procedureInputs = jsonProcedureInputs(`procedure's schema couldn't be converted to CLI arguments: ${procedureInputsResult.error}`);
-            return [procedurePath, { meta, parsedProcedure: procedureInputs, incompatiblePairs: [], procedure }];
-        }
-        const procedureInputs = procedureInputsResult.value;
-        const incompatiblePairs = (0, json_schema_1.incompatiblePropertyPairs)(procedureInputs.optionsJsonSchema);
-        return [procedurePath, { meta: getMeta(procedure), parsedProcedure: procedureInputs, incompatiblePairs, procedure }];
-    });
+  const defEntries = Object.entries(router._def.procedures);
+  return defEntries.map(([procedurePath, procedure]) => {
+    const meta = getMeta(procedure);
+    if (meta.jsonInput) {
+      return [
+        procedurePath,
+        {
+          meta,
+          parsedProcedure: jsonProcedureInputs(),
+          incompatiblePairs: [],
+          procedure,
+        },
+      ];
+    }
+    const procedureInputsResult = (0, parse_procedure_1.parseProcedureInputs)(
+      procedure._def.inputs,
+      params,
+    );
+    if (!procedureInputsResult.success) {
+      const procedureInputs = jsonProcedureInputs(
+        `procedure's schema couldn't be converted to CLI arguments: ${procedureInputsResult.error}`,
+      );
+      return [
+        procedurePath,
+        {
+          meta,
+          parsedProcedure: procedureInputs,
+          incompatiblePairs: [],
+          procedure,
+        },
+      ];
+    }
+    const procedureInputs = procedureInputsResult.value;
+    const incompatiblePairs = (0, json_schema_1.incompatiblePropertyPairs)(
+      procedureInputs.optionsJsonSchema,
+    );
+    return [
+      procedurePath,
+      {
+        meta: getMeta(procedure),
+        parsedProcedure: procedureInputs,
+        incompatiblePairs,
+        procedure,
+      },
+    ];
+  });
 };
 // We're going to use eval to require some optional dependencies. It's hard-coded, so safe, but some bundlers like tsdown will emit warnings unless we disguise it.
 const disguisedEval = eval;
 // eslint-disable-next-line @typescript-eslint/no-explicit-any
 const parseOrpcRouter = (params) => {
-    const entries = [];
-    const { traverseContractProcedures, isProcedure } = disguisedEval(`require('@orpc/server')`);
-    const router = params.router;
-    const lazyRoutes = traverseContractProcedures({ path: [], router }, ({ contract, path }) => {
-        let procedure = params.router;
-        for (const p of path)
-            procedure = procedure[p];
-        if (!isProcedure(procedure))
-            return; // if it's contract-only, we can't run it via CLI (user may have passed an implemented contract router? should we tell them? it's undefined behaviour so kinda on them)
-        const procedureInputsResult = (0, parse_procedure_1.parseProcedureInputs)([contract['~orpc'].inputSchema], {
-            '@valibot/to-json-schema': params['@valibot/to-json-schema'],
-            effect: params.effect,
-        });
-        const procedurePath = path.join('.');
-        const procedureish = { _def: { meta: contract['~orpc'].meta } };
-        const meta = getMeta(procedureish);
-        if (meta.jsonInput) {
-            entries.push([procedurePath, { meta, parsedProcedure: jsonProcedureInputs(), incompatiblePairs: [], procedure }]);
-            return;
-        }
-        if (!procedureInputsResult.success) {
-            const parsedProcedure = jsonProcedureInputs(`procedure's schema couldn't be converted to CLI arguments: ${procedureInputsResult.error}`);
-            entries.push([procedurePath, { meta, parsedProcedure: parsedProcedure, incompatiblePairs: [], procedure }]);
-            return;
-        }
-        const parsedProcedure = procedureInputsResult.value;
-        const incompatiblePairs = (0, json_schema_1.incompatiblePropertyPairs)(parsedProcedure.optionsJsonSchema);
-        entries.push([procedurePath, { procedure, meta, incompatiblePairs, parsedProcedure }]);
-    });
-    if (lazyRoutes.length) {
-        const suggestion = `Please use \`import {unlazyRouter} from '@orpc/server'\` to unlazy the router before passing it to trpc-cli`;
-        const routes = lazyRoutes.map(({ path }) => path.join('.')).join(', ');
-        throw new Error(`Lazy routers are not supported. ${suggestion}. Lazy routes detected: ${routes}`);
-    }
-    return entries;
+  const entries = [];
+  const { traverseContractProcedures, isProcedure } = disguisedEval(
+    `require('@orpc/server')`,
+  );
+  const router = params.router;
+  const lazyRoutes = traverseContractProcedures(
+    { path: [], router },
+    ({ contract, path }) => {
+      let procedure = params.router;
+      for (const p of path) procedure = procedure[p];
+      if (!isProcedure(procedure)) return; // if it's contract-only, we can't run it via CLI (user may have passed an implemented contract router? should we tell them? it's undefined behaviour so kinda on them)
+      const procedureInputsResult = (0, parse_procedure_1.parseProcedureInputs)(
+        [contract["~orpc"].inputSchema],
+        {
+          "@valibot/to-json-schema": params["@valibot/to-json-schema"],
+          effect: params.effect,
+        },
+      );
+      const procedurePath = path.join(".");
+      const procedureish = { _def: { meta: contract["~orpc"].meta } };
+      const meta = getMeta(procedureish);
+      if (meta.jsonInput) {
+        entries.push([
+          procedurePath,
+          {
+            meta,
+            parsedProcedure: jsonProcedureInputs(),
+            incompatiblePairs: [],
+            procedure,
+          },
+        ]);
+        return;
+      }
+      if (!procedureInputsResult.success) {
+        const parsedProcedure = jsonProcedureInputs(
+          `procedure's schema couldn't be converted to CLI arguments: ${procedureInputsResult.error}`,
+        );
+        entries.push([
+          procedurePath,
+          {
+            meta,
+            parsedProcedure: parsedProcedure,
+            incompatiblePairs: [],
+            procedure,
+          },
+        ]);
+        return;
+      }
+      const parsedProcedure = procedureInputsResult.value;
+      const incompatiblePairs = (0, json_schema_1.incompatiblePropertyPairs)(
+        parsedProcedure.optionsJsonSchema,
+      );
+      entries.push([
+        procedurePath,
+        { procedure, meta, incompatiblePairs, parsedProcedure },
+      ]);
+    },
+  );
+  if (lazyRoutes.length) {
+    const suggestion = `Please use \`import {unlazyRouter} from '@orpc/server'\` to unlazy the router before passing it to trpc-cli`;
+    const routes = lazyRoutes.map(({ path }) => path.join(".")).join(", ");
+    throw new Error(
+      `Lazy routers are not supported. ${suggestion}. Lazy routes detected: ${routes}`,
+    );
+  }
+  return entries;
 };
 /** helper to create a "ParsedProcedure" that just accepts a JSON string - for when we failed to parse the input schema or the use set jsonInput: true */
 const jsonProcedureInputs = (reason) => {
-    let description = `Input formatted as JSON`;
-    if (reason)
-        description += ` (${reason})`;
-    return {
-        positionalParameters: [],
-        optionsJsonSchema: {
-            type: 'object',
-            properties: {
-                input: { description }, // omit `type` - this is json input, it could be anything
-            },
-        },
-        getPojoInput: parsedCliParams => parsedCliParams.options.input,
-    };
+  let description = `Input formatted as JSON`;
+  if (reason) description += ` (${reason})`;
+  return {
+    positionalParameters: [],
+    optionsJsonSchema: {
+      type: "object",
+      properties: {
+        input: { description }, // omit `type` - this is json input, it could be anything
+      },
+    },
+    getPojoInput: (parsedCliParams) => parsedCliParams.options.input,
+  };
 };
 /**
  * Run a trpc router as a CLI.
@@ -159,440 +260,550 @@ const jsonProcedureInputs = (reason) => {
  * @returns A CLI object with a `run` method that can be called to run the CLI. The `run` method will parse the command line arguments, call the appropriate trpc procedure, log the result and exit the process. On error, it will log the error and exit with a non-zero exit code.
  */
 function createCli({ router, ...params }) {
-    const procedureEntries = (0, exports.parseRouter)({ router, ...params });
-    function buildProgram(runParams) {
-        const logger = { ...logging_1.lineByLineConsoleLogger, ...runParams?.logger };
-        const program = new Command(params.name);
-        if (params.version)
-            program.version(params.version);
-        if (params.description)
-            program.description(params.description);
-        if (params.usage)
-            [params.usage].flat().forEach(usage => program.usage(usage));
-        program.showHelpAfterError();
-        program.showSuggestionAfterError();
-        // Organize commands in a tree structure for nested subcommands
-        const commandTree = {
-            '': program, // Root level
-        };
-        // Keep track of default commands for each parent path
-        const defaultCommands = {};
-        const _process = runParams?.process || process;
-        const configureCommand = (command, procedurePath, { meta, parsedProcedure, incompatiblePairs, procedure }) => {
-            const optionJsonSchemaProperties = (0, json_schema_1.flattenedProperties)(parsedProcedure.optionsJsonSchema);
-            command.exitOverride(ec => {
-                _process.exit(ec.exitCode);
-                throw new errors_1.FailedToExitError(`Command ${command.name()} exitOverride`, { exitCode: ec.exitCode, cause: ec });
-            });
-            command.configureOutput({
-                writeOut: str => {
-                    logger.info?.(str);
-                },
-                writeErr: str => {
-                    logger.error?.(str);
-                },
-            });
-            command.showHelpAfterError();
-            if (meta.usage)
-                command.usage([meta.usage].flat().join('\n'));
-            if (meta.examples)
-                command.addHelpText('after', `\nExamples:\n${[meta.examples].flat().join('\n')}`);
-            meta?.aliases?.command?.forEach(alias => {
-                command.alias(alias);
-            });
-            command.description(meta?.description || '');
-            parsedProcedure.positionalParameters.forEach(param => {
-                const descriptionParts = [
-                    param.type === 'string' ? '' : param.type, // "string" is the default assumption, don't bother showing it
-                    param.description,
-                    param.required ? '(required)' : '',
-                ];
-                const argument = new commander_1.Argument(param.name, descriptionParts.filter(Boolean).join(' '));
-                if (param.type === 'number') {
-                    argument.argParser(value => {
-                        const number = numberParser(value, { fallback: null });
-                        if (number == null)
-                            throw new commander_1.InvalidArgumentError(`Invalid number: ${value}`);
-                        return value;
-                    });
-                }
-                argument.required = param.required;
-                argument.variadic = param.array;
-                command.addArgument(argument);
-            });
-            const unusedOptionAliases = { ...meta.aliases?.options };
-            const addOptionForProperty = ([propertyKey, propertyValue]) => {
-                const description = (0, json_schema_1.getDescription)(propertyValue);
-                const longOption = `--${kebabCase(propertyKey)}`;
-                let flags = longOption;
-                const alias = propertyValue && 'alias' in propertyValue && typeof propertyValue.alias === 'string'
-                    ? propertyValue.alias
-                    : meta.aliases?.options?.[propertyKey];
-                if (alias) {
-                    let prefix = '-';
-                    if (alias.startsWith('-'))
-                        prefix = '';
-                    else if (alias.length > 1)
-                        prefix = '--';
-                    flags = `${prefix}${alias}, ${flags}`;
-                    delete unusedOptionAliases[propertyKey];
-                }
-                const allowedSchemas = (0, json_schema_1.getAllowedSchemas)(propertyValue);
-                const firstSchemaWithDefault = allowedSchemas.find(subSchema => 'default' in subSchema);
-                const defaultValue = firstSchemaWithDefault
-                    ? { exists: true, value: firstSchemaWithDefault.default }
-                    : { exists: false };
-                const rootTypes = (0, json_schema_1.getSchemaTypes)(propertyValue).sort();
-                const propertyType = rootTypes[0];
-                const isValueRequired = 'required' in parsedProcedure.optionsJsonSchema &&
-                    parsedProcedure.optionsJsonSchema.required?.includes(propertyKey);
-                const isCliOptionRequired = isValueRequired && propertyType !== 'boolean' && !defaultValue.exists;
-                function negate() {
-                    const shouldNegate = 'negatable' in propertyValue ? propertyValue.negatable : meta.negateBooleans;
-                    if (shouldNegate) {
-                        const negation = new commander_1.Option(longOption.replace('--', '--no-'), `Negate \`${longOption}\` option.`.trim());
-                        command.addOption(negation);
-                    }
-                }
-                const bracketise = (name) => (isCliOptionRequired ? `<${name}>` : `[${name}]`);
-                if (allowedSchemas.length > 1) {
-                    const option = new commander_1.Option(`${flags} [value]`, description);
-                    if (defaultValue.exists)
-                        option.default(defaultValue.value);
-                    else if (rootTypes.includes('boolean'))
-                        option.default(false);
-                    option.argParser(getOptionValueParser(propertyValue));
-                    command.addOption(option);
-                    if (rootTypes.includes('boolean'))
-                        negate();
-                    return;
-                }
-                if (rootTypes.length !== 1) {
-                    const option = new commander_1.Option(`${flags} ${bracketise('json')}`, description);
-                    option.argParser(getOptionValueParser(propertyValue));
-                    command.addOption(option);
-                    return;
-                }
-                if (propertyType === 'boolean') {
-                    const option = new commander_1.Option(`${flags} [boolean]`, description);
-                    option.argParser(value => booleanParser(value));
-                    // don't set a default value of `false`, because `undefined` is accepted by the procedure
-                    if (isValueRequired)
-                        option.default(false);
-                    else if (defaultValue.exists)
-                        option.default(defaultValue.value);
-                    command.addOption(option);
-                    negate();
-                    return;
-                }
-                let option = null;
-                // eslint-disable-next-line unicorn/prefer-switch
-                if (propertyType === 'string') {
-                    option = new commander_1.Option(`${flags} ${bracketise('string')}`, description);
-                }
-                else if (propertyType === 'boolean') {
-                    option = new commander_1.Option(flags, description);
-                }
-                else if (propertyType === 'number' || propertyType === 'integer') {
-                    option = new commander_1.Option(`${flags} ${bracketise('number')}`, description);
-                    option.argParser(value => numberParser(value, { fallback: null }));
-                }
-                else if (propertyType === 'array') {
-                    option = new commander_1.Option(`${flags} [values...]`, description);
-                    if (defaultValue.exists)
-                        option.default(defaultValue.value);
-                    else if (isValueRequired)
-                        option.default([]);
-                    const itemsSchema = 'items' in propertyValue ? propertyValue.items : {};
-                    const itemEnumTypes = (0, json_schema_1.getEnumChoices)(itemsSchema);
-                    if (itemEnumTypes?.type === 'string_enum') {
-                        option.choices(itemEnumTypes.choices);
-                    }
-                    const itemParser = getOptionValueParser(itemsSchema);
-                    if (itemParser) {
-                        option.argParser((value, previous) => {
-                            const parsed = itemParser(value);
-                            return Array.isArray(previous) ? [...previous, parsed] : [parsed];
-                        });
-                    }
-                }
-                if (!option) {
-                    option = new commander_1.Option(`${flags} [json]`, description);
-                    option.argParser(value => parseJson(value, commander_1.InvalidOptionArgumentError));
-                }
-                if (defaultValue.exists && option.defaultValue !== defaultValue.value) {
-                    option.default(defaultValue.value);
-                }
-                if (option.flags.includes('<')) {
-                    option.makeOptionMandatory();
-                }
-                const enumChoices = (0, json_schema_1.getEnumChoices)(propertyValue);
-                if (enumChoices?.type === 'string_enum') {
-                    option.choices(enumChoices.choices);
-                }
-                option.conflicts(incompatiblePairs.flatMap(pair => {
-                    const filtered = pair.filter(p => p !== propertyKey);
-                    if (filtered.length === pair.length)
-                        return [];
-                    return filtered;
-                }));
-                command.addOption(option);
-                if (propertyType === 'boolean')
-                    negate(); // just in case we refactor the code above and don't handle booleans as a special case
-            };
-            Object.entries(optionJsonSchemaProperties).forEach(addOptionForProperty);
-            const invalidOptionAliases = Object.entries(unusedOptionAliases).map(([option, alias]) => `${option}: ${alias}`);
-            if (invalidOptionAliases.length) {
-                throw new Error(`Invalid option aliases: ${invalidOptionAliases.join(', ')}`);
-            }
-            // Set the action for this command
-            command.action(async (...args) => {
-                program.__ran ||= [];
-                program.__ran.push(command);
-                const options = command.opts();
-                if (args.at(-2) !== options) {
-                    // This is a code bug and not recoverable. Will hopefully never happen but if commander totally changes their API this will break
-                    throw new Error(`Unexpected args format, second last arg is not the options object`, { cause: args });
-                }
-                if (args.at(-1) !== command) {
-                    // This is a code bug and not recoverable. Will hopefully never happen but if commander totally changes their API this will break
-                    throw new Error(`Unexpected args format, last arg is not the Command instance`, { cause: args });
-                }
-                // the last arg is the Command instance itself, the second last is the options object, and the other args are positional
-                const positionalValues = args.slice(0, -2);
-                const input = parsedProcedure.getPojoInput({ positionalValues, options });
-                const resolvedTrpcServer = await (params.trpcServer || trpcServer11);
-                let caller;
-                const deprecatedCreateCaller = Reflect.get(params, 'createCallerFactory');
-                if (deprecatedCreateCaller) {
-                    const message = `Using deprecated \`createCallerFactory\` option. Use \`trpcServer\` instead. e.g. \`createCli({router: myRouter, trpcServer: import('@trpc/server')})\``;
-                    logger.error?.(message);
-                    caller = deprecatedCreateCaller(router)(params.context);
-                }
-                else if ((0, trpc_compat_1.isOrpcRouter)(router)) {
-                    const { call } = disguisedEval(`require('@orpc/server')`);
-                    // create an object which acts enough like a trpc caller to be used for this specific procedure
-                    caller = { [procedurePath]: (_input) => call(procedure, _input, { context: params.context }) };
-                }
-                else {
-                    const createCallerFactor = resolvedTrpcServer.initTRPC.create().createCallerFactory;
-                    caller = createCallerFactor(router)(params.context);
-                }
-                const result = await caller[procedurePath](input).catch(err => {
-                    throw transformError(err, command);
-                });
-                command.__result = result;
-                if (result != null)
-                    logger.info?.(result);
-            });
-        };
-        // Process each procedure and add as a command or subcommand
-        procedureEntries.forEach(([procedurePath, commandConfig]) => {
-            const segments = procedurePath.split('.');
-            // Create the command path and ensure parent commands exist
-            let currentPath = '';
-            for (let i = 0; i < segments.length - 1; i++) {
-                const segment = segments[i];
-                const parentPath = currentPath;
-                currentPath = currentPath ? `${currentPath}.${segment}` : segment;
-                // Create parent command if it doesn't exist
-                if (!commandTree[currentPath]) {
-                    const parentCommand = commandTree[parentPath];
-                    const newCommand = new Command(kebabCase(segment));
-                    newCommand.showHelpAfterError();
-                    parentCommand.addCommand(newCommand);
-                    commandTree[currentPath] = newCommand;
-                }
-            }
-            // Create the actual leaf command
-            const leafName = segments.at(-1);
-            const parentPath = segments.length > 1 ? segments.slice(0, -1).join('.') : '';
-            const parentCommand = commandTree[parentPath];
-            const leafCommand = new Command(leafName && kebabCase(leafName));
-            configureCommand(leafCommand, procedurePath, commandConfig);
-            parentCommand.addCommand(leafCommand);
-            // Check if this command should be the default for its parent
-            const meta = commandConfig.meta;
-            if (meta.default === true) {
-                // the parent will pass on its args straight to the child, which will validate them. the parent just blindly accepts anything.
-                parentCommand.allowExcessArguments();
-                parentCommand.allowUnknownOption();
-                parentCommand.addHelpText('after', leafCommand.helpInformation());
-                parentCommand.action(async () => {
-                    await leafCommand.parseAsync([...parentCommand.args], { from: 'user' });
-                });
-                // ancestors need to support positional options to pass through the positional args
-                // for (let ancestor = parentCommand.parent, i = 0; ancestor && i < 10; ancestor = ancestor.parent, i++) {
-                //   ancestor.enablePositionalOptions()
-                // }
-                // parentCommand.passThroughOptions()
-                defaultCommands[parentPath] = {
-                    procedurePath: procedurePath,
-                    config: commandConfig,
-                    command: leafCommand,
-                };
-            }
-        });
-        // After all commands are added, generate descriptions for parent commands
-        Object.entries(commandTree).forEach(([path, command]) => {
-            // Skip the root command and leaf commands (which already have descriptions)
-            // if (path === '' || command.commands.length === 0) return
-            if (command.commands.length === 0)
-                return;
-            // Get the names of all direct subcommands
-            const subcommandNames = command.commands.map(cmd => cmd.name());
-            // Check if there's a default command for this path
-            const defaultCommand = defaultCommands[path]?.command.name();
-            // Format the subcommand list, marking the default one
-            const formattedSubcommands = subcommandNames
-                .map(name => (name === defaultCommand ? `${name} (default)` : name))
-                .join(', ');
-            // Get the existing description (might have been set by a default command)
-            const existingDescription = command.description() || '';
-            // Only add the subcommand list if it's not already part of the description
-            const descriptionParts = [existingDescription, `Available subcommands: ${formattedSubcommands}`];
-            command.description(descriptionParts.filter(Boolean).join('\n'));
-        });
-        return program;
-    }
-    const run = async (runParams, program = buildProgram(runParams)) => {
-        if (!(0, util_2.looksLikeInstanceof)(program, 'Command'))
-            throw new Error(`program is not a Command instance`);
-        const opts = runParams?.argv ? { from: 'user' } : undefined;
-        const argv = [...(runParams?.argv || process.argv)];
-        const _process = runParams?.process || process;
-        const logger = { ...logging_1.lineByLineConsoleLogger, ...runParams?.logger };
-        program.exitOverride(exit => {
-            _process.exit(exit.exitCode);
-            throw new errors_1.FailedToExitError('Root command exitOverride', { exitCode: exit.exitCode, cause: exit });
-        });
-        program.configureOutput({
-            writeOut: str => logger.info?.(str),
-            writeErr: str => logger.error?.(str),
-        });
-        if (runParams?.completion) {
-            const completion = typeof runParams.completion === 'function' ? await runParams.completion() : runParams.completion;
-            (0, completions_1.addCompletions)(program, completion);
+  const procedureEntries = (0, exports.parseRouter)({ router, ...params });
+  function buildProgram(runParams) {
+    const logger = {
+      ...logging_1.lineByLineConsoleLogger,
+      ...runParams?.logger,
+    };
+    const program = new Command(params.name);
+    if (params.version) program.version(params.version);
+    if (params.description) program.description(params.description);
+    if (params.usage)
+      [params.usage].flat().forEach((usage) => program.usage(usage));
+    program.showHelpAfterError();
+    program.showSuggestionAfterError();
+    // Organize commands in a tree structure for nested subcommands
+    const commandTree = {
+      "": program, // Root level
+    };
+    // Keep track of default commands for each parent path
+    const defaultCommands = {};
+    const _process = runParams?.process || process;
+    const configureCommand = (
+      command,
+      procedurePath,
+      { meta, parsedProcedure, incompatiblePairs, procedure },
+    ) => {
+      const optionJsonSchemaProperties = (0, json_schema_1.flattenedProperties)(
+        parsedProcedure.optionsJsonSchema,
+      );
+      command.exitOverride((ec) => {
+        _process.exit(ec.exitCode);
+        throw new errors_1.FailedToExitError(
+          `Command ${command.name()} exitOverride`,
+          { exitCode: ec.exitCode, cause: ec },
+        );
+      });
+      command.configureOutput({
+        writeOut: (str) => {
+          logger.info?.(str);
+        },
+        writeErr: (str) => {
+          logger.info?.(str);
+        },
+      });
+      command.showHelpAfterError();
+      if (meta.usage) command.usage([meta.usage].flat().join("\n"));
+      if (meta.examples)
+        command.addHelpText(
+          "after",
+          `\nExamples:\n${[meta.examples].flat().join("\n")}`,
+        );
+      meta?.aliases?.command?.forEach((alias) => {
+        command.alias(alias);
+      });
+      command.description(meta?.description || "");
+      parsedProcedure.positionalParameters.forEach((param) => {
+        const descriptionParts = [
+          param.type === "string" ? "" : param.type, // "string" is the default assumption, don't bother showing it
+          param.description,
+          param.required ? "(required)" : "",
+        ];
+        const argument = new commander_1.Argument(
+          param.name,
+          descriptionParts.filter(Boolean).join(" "),
+        );
+        if (param.type === "number") {
+          argument.argParser((value) => {
+            const number = numberParser(value, { fallback: null });
+            if (number == null)
+              throw new commander_1.InvalidArgumentError(
+                `Invalid number: ${value}`,
+              );
+            return value;
+          });
+        }
+        argument.required = param.required;
+        argument.variadic = param.array;
+        command.addArgument(argument);
+      });
+      const unusedOptionAliases = { ...meta.aliases?.options };
+      const addOptionForProperty = ([propertyKey, propertyValue]) => {
+        const description = (0, json_schema_1.getDescription)(propertyValue);
+        const longOption = `--${kebabCase(propertyKey)}`;
+        let flags = longOption;
+        const alias =
+          propertyValue &&
+          "alias" in propertyValue &&
+          typeof propertyValue.alias === "string"
+            ? propertyValue.alias
+            : meta.aliases?.options?.[propertyKey];
+        if (alias) {
+          let prefix = "-";
+          if (alias.startsWith("-")) prefix = "";
+          else if (alias.length > 1) prefix = "--";
+          flags = `${prefix}${alias}, ${flags}`;
+          delete unusedOptionAliases[propertyKey];
+        }
+        const allowedSchemas = (0, json_schema_1.getAllowedSchemas)(
+          propertyValue,
+        );
+        const firstSchemaWithDefault = allowedSchemas.find(
+          (subSchema) => "default" in subSchema,
+        );
+        const defaultValue = firstSchemaWithDefault
+          ? { exists: true, value: firstSchemaWithDefault.default }
+          : { exists: false };
+        const rootTypes = (0, json_schema_1.getSchemaTypes)(
+          propertyValue,
+        ).sort();
+        const propertyType = rootTypes[0];
+        const isValueRequired =
+          "required" in parsedProcedure.optionsJsonSchema &&
+          parsedProcedure.optionsJsonSchema.required?.includes(propertyKey);
+        const isCliOptionRequired =
+          isValueRequired && propertyType !== "boolean" && !defaultValue.exists;
+        function negate() {
+          const shouldNegate =
+            "negatable" in propertyValue
+              ? propertyValue.negatable
+              : meta.negateBooleans;
+          if (shouldNegate) {
+            const negation = new commander_1.Option(
+              longOption.replace("--", "--no-"),
+              `Negate \`${longOption}\` option.`.trim(),
+            );
+            command.addOption(negation);
+          }
         }
-        const formatError = runParams?.formatError ||
-            ((err) => {
-                if (err instanceof errors_1.CliValidationError) {
-                    return err.message;
-                }
-                return (0, util_1.inspect)(err);
+        const bracketise = (name) =>
+          isCliOptionRequired ? `<${name}>` : `[${name}]`;
+        if (allowedSchemas.length > 1) {
+          const option = new commander_1.Option(
+            `${flags} [value]`,
+            description,
+          );
+          if (defaultValue.exists) option.default(defaultValue.value);
+          else if (rootTypes.includes("boolean")) option.default(false);
+          option.argParser(getOptionValueParser(propertyValue));
+          command.addOption(option);
+          if (rootTypes.includes("boolean")) negate();
+          return;
+        }
+        if (rootTypes.length !== 1) {
+          const option = new commander_1.Option(
+            `${flags} ${bracketise("json")}`,
+            description,
+          );
+          option.argParser(getOptionValueParser(propertyValue));
+          command.addOption(option);
+          return;
+        }
+        if (propertyType === "boolean") {
+          const option = new commander_1.Option(
+            `${flags} [boolean]`,
+            description,
+          );
+          option.argParser((value) => booleanParser(value));
+          // don't set a default value of `false`, because `undefined` is accepted by the procedure
+          if (isValueRequired) option.default(false);
+          else if (defaultValue.exists) option.default(defaultValue.value);
+          command.addOption(option);
+          negate();
+          return;
+        }
+        let option = null;
+        // eslint-disable-next-line unicorn/prefer-switch
+        if (propertyType === "string") {
+          option = new commander_1.Option(
+            `${flags} ${bracketise("string")}`,
+            description,
+          );
+        } else if (propertyType === "boolean") {
+          option = new commander_1.Option(flags, description);
+        } else if (propertyType === "number" || propertyType === "integer") {
+          option = new commander_1.Option(
+            `${flags} ${bracketise("number")}`,
+            description,
+          );
+          option.argParser((value) => numberParser(value, { fallback: null }));
+        } else if (propertyType === "array") {
+          option = new commander_1.Option(`${flags} [values...]`, description);
+          if (defaultValue.exists) option.default(defaultValue.value);
+          else if (isValueRequired) option.default([]);
+          const itemsSchema =
+            "items" in propertyValue ? propertyValue.items : {};
+          const itemEnumTypes = (0, json_schema_1.getEnumChoices)(itemsSchema);
+          if (itemEnumTypes?.type === "string_enum") {
+            option.choices(itemEnumTypes.choices);
+          }
+          const itemParser = getOptionValueParser(itemsSchema);
+          if (itemParser) {
+            option.argParser((value, previous) => {
+              const parsed = itemParser(value);
+              return Array.isArray(previous) ? [...previous, parsed] : [parsed];
             });
-        if (runParams?.prompts) {
-            program = (0, prompts_1.promptify)(program, runParams.prompts);
+          }
+        }
+        if (!option) {
+          option = new commander_1.Option(`${flags} [json]`, description);
+          option.argParser((value) =>
+            parseJson(value, commander_1.InvalidOptionArgumentError),
+          );
+        }
+        if (defaultValue.exists && option.defaultValue !== defaultValue.value) {
+          option.default(defaultValue.value);
+        }
+        if (option.flags.includes("<")) {
+          option.makeOptionMandatory();
         }
-        await program.parseAsync(argv, opts).catch(err => {
-            if (err instanceof errors_1.FailedToExitError)
-                throw err;
-            const logMessage = (0, util_2.looksLikeInstanceof)(err, Error)
-                ? formatError(err) || err.message
-                : `Non-error of type ${typeof err} thrown: ${err}`;
-            logger.error?.(logMessage);
-            _process.exit(1);
-            throw new errors_1.FailedToExitError(`Program exit after failure`, { exitCode: 1, cause: err });
+        const enumChoices = (0, json_schema_1.getEnumChoices)(propertyValue);
+        if (enumChoices?.type === "string_enum") {
+          option.choices(enumChoices.choices);
+        }
+        option.conflicts(
+          incompatiblePairs.flatMap((pair) => {
+            const filtered = pair.filter((p) => p !== propertyKey);
+            if (filtered.length === pair.length) return [];
+            return filtered;
+          }),
+        );
+        command.addOption(option);
+        if (propertyType === "boolean") negate(); // just in case we refactor the code above and don't handle booleans as a special case
+      };
+      Object.entries(optionJsonSchemaProperties).forEach(addOptionForProperty);
+      const invalidOptionAliases = Object.entries(unusedOptionAliases).map(
+        ([option, alias]) => `${option}: ${alias}`,
+      );
+      if (invalidOptionAliases.length) {
+        throw new Error(
+          `Invalid option aliases: ${invalidOptionAliases.join(", ")}`,
+        );
+      }
+      // Set the action for this command
+      command.action(async (...args) => {
+        program.__ran ||= [];
+        program.__ran.push(command);
+        const options = command.opts();
+        if (args.at(-2) !== options) {
+          // This is a code bug and not recoverable. Will hopefully never happen but if commander totally changes their API this will break
+          throw new Error(
+            `Unexpected args format, second last arg is not the options object`,
+            { cause: args },
+          );
+        }
+        if (args.at(-1) !== command) {
+          // This is a code bug and not recoverable. Will hopefully never happen but if commander totally changes their API this will break
+          throw new Error(
+            `Unexpected args format, last arg is not the Command instance`,
+            { cause: args },
+          );
+        }
+        // the last arg is the Command instance itself, the second last is the options object, and the other args are positional
+        const positionalValues = args.slice(0, -2);
+        const input = parsedProcedure.getPojoInput({
+          positionalValues,
+          options,
         });
-        _process.exit(0);
-        throw new errors_1.FailedToExitError('Program exit after success', {
-            exitCode: 0,
-            cause: program.__ran.at(-1)?.__result,
+        const resolvedTrpcServer = await (params.trpcServer || trpcServer11);
+        let caller;
+        const deprecatedCreateCaller = Reflect.get(
+          params,
+          "createCallerFactory",
+        );
+        if (deprecatedCreateCaller) {
+          const message = `Using deprecated \`createCallerFactory\` option. Use \`trpcServer\` instead. e.g. \`createCli({router: myRouter, trpcServer: import('@trpc/server')})\``;
+          logger.error?.(message);
+          caller = deprecatedCreateCaller(router)(params.context);
+        } else if ((0, trpc_compat_1.isOrpcRouter)(router)) {
+          const { call } = disguisedEval(`require('@orpc/server')`);
+          // create an object which acts enough like a trpc caller to be used for this specific procedure
+          caller = {
+            [procedurePath]: (_input) =>
+              call(procedure, _input, { context: params.context }),
+          };
+        } else {
+          const createCallerFactor =
+            resolvedTrpcServer.initTRPC.create().createCallerFactory;
+          caller = createCallerFactor(router)(params.context);
+        }
+        const result = await caller[procedurePath](input).catch((err) => {
+          throw transformError(err, command);
         });
+        command.__result = result;
+        if (result != null) logger.info?.(result);
+      });
     };
-    return { run, buildProgram, toJSON: (program = buildProgram()) => (0, json_1.commandToJSON)(program) };
+    // Process each procedure and add as a command or subcommand
+    procedureEntries.forEach(([procedurePath, commandConfig]) => {
+      const segments = procedurePath.split(".");
+      // Create the command path and ensure parent commands exist
+      let currentPath = "";
+      for (let i = 0; i < segments.length - 1; i++) {
+        const segment = segments[i];
+        const parentPath = currentPath;
+        currentPath = currentPath ? `${currentPath}.${segment}` : segment;
+        // Create parent command if it doesn't exist
+        if (!commandTree[currentPath]) {
+          const parentCommand = commandTree[parentPath];
+          const newCommand = new Command(kebabCase(segment));
+          newCommand.showHelpAfterError();
+          parentCommand.addCommand(newCommand);
+          commandTree[currentPath] = newCommand;
+        }
+      }
+      // Create the actual leaf command
+      const leafName = segments.at(-1);
+      const parentPath =
+        segments.length > 1 ? segments.slice(0, -1).join(".") : "";
+      const parentCommand = commandTree[parentPath];
+      const leafCommand = new Command(leafName && kebabCase(leafName));
+      configureCommand(leafCommand, procedurePath, commandConfig);
+      parentCommand.addCommand(leafCommand);
+      // Check if this command should be the default for its parent
+      const meta = commandConfig.meta;
+      if (meta.default === true) {
+        // the parent will pass on its args straight to the child, which will validate them. the parent just blindly accepts anything.
+        parentCommand.allowExcessArguments();
+        parentCommand.allowUnknownOption();
+        parentCommand.addHelpText("after", leafCommand.helpInformation());
+        parentCommand.action(async () => {
+          await leafCommand.parseAsync([...parentCommand.args], {
+            from: "user",
+          });
+        });
+        // ancestors need to support positional options to pass through the positional args
+        // for (let ancestor = parentCommand.parent, i = 0; ancestor && i < 10; ancestor = ancestor.parent, i++) {
+        //   ancestor.enablePositionalOptions()
+        // }
+        // parentCommand.passThroughOptions()
+        defaultCommands[parentPath] = {
+          procedurePath: procedurePath,
+          config: commandConfig,
+          command: leafCommand,
+        };
+      }
+    });
+    // After all commands are added, generate descriptions for parent commands
+    Object.entries(commandTree).forEach(([path, command]) => {
+      // Skip the root command and leaf commands (which already have descriptions)
+      // if (path === '' || command.commands.length === 0) return
+      if (command.commands.length === 0) return;
+      // Get the names of all direct subcommands
+      const subcommandNames = command.commands.map((cmd) => cmd.name());
+      // Check if there's a default command for this path
+      const defaultCommand = defaultCommands[path]?.command.name();
+      // Format the subcommand list, marking the default one
+      const formattedSubcommands = subcommandNames
+        .map((name) => (name === defaultCommand ? `${name} (default)` : name))
+        .join(", ");
+      // Get the existing description (might have been set by a default command)
+      const existingDescription = command.description() || "";
+      // Only add the subcommand list if it's not already part of the description
+      const descriptionParts = [
+        existingDescription,
+        `Available subcommands: ${formattedSubcommands}`,
+      ];
+      command.description(descriptionParts.filter(Boolean).join("\n"));
+    });
+    return program;
+  }
+  const run = async (runParams, program = buildProgram(runParams)) => {
+    if (!(0, util_2.looksLikeInstanceof)(program, "Command"))
+      throw new Error(`program is not a Command instance`);
+    const opts = runParams?.argv ? { from: "user" } : undefined;
+    const argv = [...(runParams?.argv || process.argv)];
+    const _process = runParams?.process || process;
+    const logger = {
+      ...logging_1.lineByLineConsoleLogger,
+      ...runParams?.logger,
+    };
+    program.exitOverride((exit) => {
+      _process.exit(exit.exitCode);
+      throw new errors_1.FailedToExitError("Root command exitOverride", {
+        exitCode: exit.exitCode,
+        cause: exit,
+      });
+    });
+    program.configureOutput({
+      writeOut: (str) => logger.info?.(str),
+      writeErr: (str) => logger.info?.(str),
+    });
+    if (runParams?.completion) {
+      const completion =
+        typeof runParams.completion === "function"
+          ? await runParams.completion()
+          : runParams.completion;
+      (0, completions_1.addCompletions)(program, completion);
+    }
+    const formatError =
+      runParams?.formatError ||
+      ((err) => {
+        if (err instanceof errors_1.CliValidationError) {
+          return err.message;
+        }
+        return (0, util_1.inspect)(err);
+      });
+    if (runParams?.prompts) {
+      program = (0, prompts_1.promptify)(program, runParams.prompts);
+    }
+    await program.parseAsync(argv, opts).catch((err) => {
+      if (err instanceof errors_1.FailedToExitError) throw err;
+      const logMessage = (0, util_2.looksLikeInstanceof)(err, Error)
+        ? formatError(err) || err.message
+        : `Non-error of type ${typeof err} thrown: ${err}`;
+      logger.error?.(logMessage);
+      _process.exit(1);
+      throw new errors_1.FailedToExitError(`Program exit after failure`, {
+        exitCode: 1,
+        cause: err,
+      });
+    });
+    _process.exit(0);
+    throw new errors_1.FailedToExitError("Program exit after success", {
+      exitCode: 0,
+      cause: program.__ran.at(-1)?.__result,
+    });
+  };
+  return {
+    run,
+    buildProgram,
+    toJSON: (program = buildProgram()) => (0, json_1.commandToJSON)(program),
+  };
 }
 function getMeta(procedure) {
-    const meta = procedure._def.meta;
-    return meta?.cliMeta || meta || {};
+  const meta = procedure._def.meta;
+  return meta?.cliMeta || meta || {};
 }
 function kebabCase(propName) {
-    return propName.replaceAll(/([A-Z])/g, '-$1').toLowerCase();
+  return propName.replaceAll(/([A-Z])/g, "-$1").toLowerCase();
 }
 /** @deprecated renamed to `createCli` */
 exports.trpcCli = createCli;
 function transformError(err, command) {
-    if ((0, util_2.looksLikeInstanceof)(err, Error) && err.message.includes('This is a client-only function')) {
-        return new Error('Failed to create trpc caller. If using trpc v10, either upgrade to v11 or pass in the `@trpc/server` module to `createCli` explicitly');
+  if (
+    (0, util_2.looksLikeInstanceof)(err, Error) &&
+    err.message.includes("This is a client-only function")
+  ) {
+    return new Error(
+      "Failed to create trpc caller. If using trpc v10, either upgrade to v11 or pass in the `@trpc/server` module to `createCli` explicitly",
+    );
+  }
+  if ((0, util_2.looksLikeInstanceof)(err, "TRPCError")) {
+    const cause = err.cause;
+    if ((0, utils_1.looksLikeStandardSchemaFailure)(cause)) {
+      return new errors_1.CliValidationError(command.helpInformation());
     }
-    if ((0, util_2.looksLikeInstanceof)(err, 'TRPCError')) {
-        const cause = err.cause;
-        if ((0, utils_1.looksLikeStandardSchemaFailure)(cause)) {
-            const prettyMessage = (0, errors_2.prettifyStandardSchemaError)(cause);
-            return new errors_1.CliValidationError(prettyMessage + '\n\n' + command.helpInformation());
-        }
-        if (err.code === 'BAD_REQUEST' &&
-            (err.cause?.constructor?.name === 'TraversalError' || // arktype error
-                err.cause?.constructor?.name === 'StandardSchemaV1Error') // valibot error
-        ) {
-            return new errors_1.CliValidationError(err.cause.message + '\n\n' + command.helpInformation());
-        }
-        if (err.code === 'INTERNAL_SERVER_ERROR') {
-            return cause;
-        }
+    if (
+      err.code === "BAD_REQUEST" &&
+      (err.cause?.constructor?.name === "TraversalError" || // arktype error
+        err.cause?.constructor?.name === "StandardSchemaV1Error") // valibot error
+    ) {
+      return new errors_1.CliValidationError(command.helpInformation());
     }
-    return err;
+    if (err.code === "INTERNAL_SERVER_ERROR") {
+      return cause;
+    }
+  }
+  return err;
 }
 var errors_3 = require("./errors");
-Object.defineProperty(exports, "FailedToExitError", { enumerable: true, get: function () { return errors_3.FailedToExitError; } });
-Object.defineProperty(exports, "CliValidationError", { enumerable: true, get: function () { return errors_3.CliValidationError; } });
+Object.defineProperty(exports, "FailedToExitError", {
+  enumerable: true,
+  get: function () {
+    return errors_3.FailedToExitError;
+  },
+});
+Object.defineProperty(exports, "CliValidationError", {
+  enumerable: true,
+  get: function () {
+    return errors_3.CliValidationError;
+  },
+});
 const numberParser = (val, { fallback = val } = {}) => {
-    const number = Number(val);
-    return Number.isNaN(number) ? fallback : number;
+  const number = Number(val);
+  return Number.isNaN(number) ? fallback : number;
 };
 const booleanParser = (val, { fallback = val } = {}) => {
-    if (val === 'true')
-        return true;
-    if (val === 'false')
-        return false;
-    return fallback;
+  if (val === "true") return true;
+  if (val === "false") return false;
+  return fallback;
 };
 const getOptionValueParser = (schema) => {
-    const allowedSchemas = (0, json_schema_1.getAllowedSchemas)(schema)
-        .slice()
-        .sort((a, b) => String((0, json_schema_1.getSchemaTypes)(a)[0]).localeCompare(String((0, json_schema_1.getSchemaTypes)(b)[0])));
-    const typesArray = allowedSchemas.flatMap(json_schema_1.getSchemaTypes);
-    const types = new Set(typesArray);
-    return (value) => {
-        const definitelyPrimitive = typesArray.every(t => t === 'boolean' || t === 'number' || t === 'integer' || t === 'string');
-        if (types.size === 0 || !definitelyPrimitive) {
-            // parse this as JSON - too risky to fall back to a string because that will probably do the wrong thing if someone passes malformed JSON like `{"foo": 1,}` (trailing comma)
-            const hint = `Malformed JSON. If passing a string, pass it as a valid JSON string with quotes (${JSON.stringify(value)})`;
-            const parsed = parseJson(value, commander_1.InvalidOptionArgumentError, hint);
-            if (!types.size)
-                return parsed; // if types is empty, it means any type is allowed - e.g. for json input
-            const jsonSchemaType = Array.isArray(parsed) ? 'array' : parsed === null ? 'null' : typeof parsed;
-            if (!types.has(jsonSchemaType)) {
-                throw new commander_1.InvalidOptionArgumentError(`Got ${jsonSchemaType} but expected ${[...types].join(' or ')}`);
-            }
-            return parsed;
-        }
-        if (types.has('boolean')) {
-            const parsed = booleanParser(value, { fallback: null });
-            if (typeof parsed === 'boolean')
-                return parsed;
-        }
-        if (types.has('number')) {
-            const parsed = numberParser(value, { fallback: null });
-            if (typeof parsed === 'number')
-                return parsed;
-        }
-        if (types.has('integer')) {
-            const parsed = numberParser(value, { fallback: null });
-            if (typeof parsed === 'number' && Number.isInteger(parsed))
-                return parsed;
-        }
-        if (types.has('string')) {
-            return value;
-        }
-        throw new commander_1.InvalidOptionArgumentError(`Got ${JSON.stringify(value)} but expected ${[...types].join(' or ')}`);
-    };
-};
-const parseJson = (value, ErrorClass = commander_1.InvalidArgumentError, hint = `Malformed JSON.`) => {
-    try {
-        return JSON.parse(value);
+  const allowedSchemas = (0, json_schema_1.getAllowedSchemas)(schema)
+    .slice()
+    .sort((a, b) =>
+      String((0, json_schema_1.getSchemaTypes)(a)[0]).localeCompare(
+        String((0, json_schema_1.getSchemaTypes)(b)[0]),
+      ),
+    );
+  const typesArray = allowedSchemas.flatMap(json_schema_1.getSchemaTypes);
+  const types = new Set(typesArray);
+  return (value) => {
+    const definitelyPrimitive = typesArray.every(
+      (t) =>
+        t === "boolean" || t === "number" || t === "integer" || t === "string",
+    );
+    if (types.size === 0 || !definitelyPrimitive) {
+      // parse this as JSON - too risky to fall back to a string because that will probably do the wrong thing if someone passes malformed JSON like `{"foo": 1,}` (trailing comma)
+      const hint = `Malformed JSON. If passing a string, pass it as a valid JSON string with quotes (${JSON.stringify(value)})`;
+      const parsed = parseJson(
+        value,
+        commander_1.InvalidOptionArgumentError,
+        hint,
+      );
+      if (!types.size) return parsed; // if types is empty, it means any type is allowed - e.g. for json input
+      const jsonSchemaType = Array.isArray(parsed)
+        ? "array"
+        : parsed === null
+          ? "null"
+          : typeof parsed;
+      if (!types.has(jsonSchemaType)) {
+        throw new commander_1.InvalidOptionArgumentError(
+          `Got ${jsonSchemaType} but expected ${[...types].join(" or ")}`,
+        );
+      }
+      return parsed;
+    }
+    if (types.has("boolean")) {
+      const parsed = booleanParser(value, { fallback: null });
+      if (typeof parsed === "boolean") return parsed;
+    }
+    if (types.has("number")) {
+      const parsed = numberParser(value, { fallback: null });
+      if (typeof parsed === "number") return parsed;
     }
-    catch {
-        throw new ErrorClass(hint);
+    if (types.has("integer")) {
+      const parsed = numberParser(value, { fallback: null });
+      if (typeof parsed === "number" && Number.isInteger(parsed)) return parsed;
     }
+    if (types.has("string")) {
+      return value;
+    }
+    throw new commander_1.InvalidOptionArgumentError(
+      `Got ${JSON.stringify(value)} but expected ${[...types].join(" or ")}`,
+    );
+  };
+};
+const parseJson = (
+  value,
+  ErrorClass = commander_1.InvalidArgumentError,
+  hint = `Malformed JSON.`,
+) => {
+  try {
+    return JSON.parse(value);
+  } catch {
+    throw new ErrorClass(hint);
+  }
 };
diff --git a/dist/logging.js b/dist/logging.js
index 36aee4c8e402c1c30cc1d5f294d99580b5a00a13..f3b20d5cc6a4810906f4cd3337b56a654ff36c4f 100644
--- a/dist/logging.js
+++ b/dist/logging.js
@@ -1,38 +1,35 @@
 "use strict";
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.lineByLineConsoleLogger = exports.lineByLineLogger = void 0;
-exports.lineByLineLogger = getLoggerTransformer(log => {
-    /**
-     * @param args values to log. if `logger.info('a', 1)` is called, `args` will be `['a', 1]`
-     * @param depth tracks whether the current call recursive. Used to make sure we don't flatten nested arrays
-     */
-    const wrapper = (args, depth) => {
-        if (args.length === 1 && Array.isArray(args[0]) && depth === 0) {
-            args[0].forEach(item => wrapper([item], 1));
-        }
-        else if (args.every(isPrimitive)) {
-            log(...args);
-        }
-        else if (args.length === 1) {
-            log(JSON.stringify(args[0], null, 2));
-        }
-        else {
-            log(JSON.stringify(args, null, 2));
-        }
-    };
-    return (...args) => wrapper(args, 0);
+exports.lineByLineLogger = getLoggerTransformer((log) => {
+  /**
+   * @param args values to log. if `logger.info('a', 1)` is called, `args` will be `['a', 1]`
+   * @param depth tracks whether the current call recursive. Used to make sure we don't flatten nested arrays
+   */
+  const wrapper = (args, depth) => {
+    if (args.length === 1 && Array.isArray(args[0]) && depth === 0) {
+      args[0].forEach((item) => wrapper([item], 1));
+    } else if (args.every(isPrimitive)) {
+      log(...args);
+    } else if (args.length === 1) {
+      log(JSON.stringify(args[0], null, 2));
+    } else {
+      log(JSON.stringify(args, null, 2));
+    }
+  };
+  return (...args) => wrapper(args, 0);
 });
 const isPrimitive = (value) => {
-    const type = typeof value;
-    return type === 'string' || type === 'number' || type === 'boolean';
+  const type = typeof value;
+  return type === "string" || type === "number" || type === "boolean";
 };
 /** Takes a function that wraps an individual log function, and returns a function that wraps the `info` and `error` functions for a logger */
 function getLoggerTransformer(transform) {
-    return (logger) => {
-        const info = logger.info && transform(logger.info);
-        const error = logger.error && transform(logger.error);
-        return { info, error };
-    };
+  return (logger) => {
+    const info = logger.info && transform(logger.info);
+    const error = logger.error && transform(logger.error);
+    return { info, error };
+  };
 }
 /**
  * A logger which uses `console.log` and `console.error` to log in the following way:
diff --git a/dist/parse-procedure.js b/dist/parse-procedure.js
index 5e9cec34577307de202c4beaa1d244f7867f0577..0a06a27ab2a87422defad280e46aa26eb81478ee 100644
--- a/dist/parse-procedure.js
+++ b/dist/parse-procedure.js
@@ -1,40 +1,65 @@
 "use strict";
-var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
-    if (k2 === undefined) k2 = k;
-    var desc = Object.getOwnPropertyDescriptor(m, k);
-    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
-      desc = { enumerable: true, get: function() { return m[k]; } };
-    }
-    Object.defineProperty(o, k2, desc);
-}) : (function(o, m, k, k2) {
-    if (k2 === undefined) k2 = k;
-    o[k2] = m[k];
-}));
-var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
-    Object.defineProperty(o, "default", { enumerable: true, value: v });
-}) : function(o, v) {
-    o["default"] = v;
-});
-var __importStar = (this && this.__importStar) || (function () {
-    var ownKeys = function(o) {
-        ownKeys = Object.getOwnPropertyNames || function (o) {
-            var ar = [];
-            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
-            return ar;
+var __createBinding =
+  (this && this.__createBinding) ||
+  (Object.create
+    ? function (o, m, k, k2) {
+        if (k2 === undefined) k2 = k;
+        var desc = Object.getOwnPropertyDescriptor(m, k);
+        if (
+          !desc ||
+          ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)
+        ) {
+          desc = {
+            enumerable: true,
+            get: function () {
+              return m[k];
+            },
+          };
+        }
+        Object.defineProperty(o, k2, desc);
+      }
+    : function (o, m, k, k2) {
+        if (k2 === undefined) k2 = k;
+        o[k2] = m[k];
+      });
+var __setModuleDefault =
+  (this && this.__setModuleDefault) ||
+  (Object.create
+    ? function (o, v) {
+        Object.defineProperty(o, "default", { enumerable: true, value: v });
+      }
+    : function (o, v) {
+        o["default"] = v;
+      });
+var __importStar =
+  (this && this.__importStar) ||
+  (function () {
+    var ownKeys = function (o) {
+      ownKeys =
+        Object.getOwnPropertyNames ||
+        function (o) {
+          var ar = [];
+          for (var k in o)
+            if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
+          return ar;
         };
-        return ownKeys(o);
+      return ownKeys(o);
     };
     return function (mod) {
-        if (mod && mod.__esModule) return mod;
-        var result = {};
-        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
-        __setModuleDefault(result, mod);
-        return result;
+      if (mod && mod.__esModule) return mod;
+      var result = {};
+      if (mod != null)
+        for (var k = ownKeys(mod), i = 0; i < k.length; i++)
+          if (k[i] !== "default") __createBinding(result, mod, k[i]);
+      __setModuleDefault(result, mod);
+      return result;
     };
-})();
-var __importDefault = (this && this.__importDefault) || function (mod) {
-    return (mod && mod.__esModule) ? mod : { "default": mod };
-};
+  })();
+var __importDefault =
+  (this && this.__importDefault) ||
+  function (mod) {
+    return mod && mod.__esModule ? mod : { default: mod };
+  };
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.parseProcedureInputs = parseProcedureInputs;
 const util_1 = require("util");
@@ -49,380 +74,455 @@ const disguisedEval = eval;
  * Uses @see jsonSchemaConverters to convert the input to JSON schema.
  */
 function toJsonSchema(input, dependencies) {
-    try {
-        const jsonSchemaConverters = getJsonSchemaConverters(dependencies);
-        const vendor = getVendor(input);
-        if (vendor && vendor in jsonSchemaConverters) {
-            const converter = jsonSchemaConverters[vendor];
-            const converted = converter(input);
-            return { success: true, value: converted };
-        }
-        return { success: false, error: `Schema not convertible to JSON schema` };
-    }
-    catch (e) {
-        const message = e instanceof Error ? e.message : String(e);
-        return { success: false, error: `Failed to convert input to JSON Schema: ${message}` };
+  try {
+    const jsonSchemaConverters = getJsonSchemaConverters(dependencies);
+    const vendor = getVendor(input);
+    if (vendor && vendor in jsonSchemaConverters) {
+      const converter = jsonSchemaConverters[vendor];
+      const converted = converter(input);
+      return { success: true, value: converted };
     }
+    return { success: false, error: `Schema not convertible to JSON schema` };
+  } catch (e) {
+    const message = e instanceof Error ? e.message : String(e);
+    return {
+      success: false,
+      error: `Failed to convert input to JSON Schema: ${message}`,
+    };
+  }
 }
 function looksLikeJsonSchema(value) {
-    return (typeof value === 'object' &&
-        value !== null &&
-        (('type' in value && (typeof value.type === 'string' || Array.isArray(value.type))) ||
-            'const' in value ||
-            'oneOf' in value ||
-            'anyOf' in value));
+  return (
+    typeof value === "object" &&
+    value !== null &&
+    (("type" in value &&
+      (typeof value.type === "string" || Array.isArray(value.type))) ||
+      "const" in value ||
+      "oneOf" in value ||
+      "anyOf" in value)
+  );
 }
 function parseProcedureInputs(inputs, dependencies) {
-    const inner = parseProcedureInputsInner(inputs, dependencies);
-    if (inner.success && inner.value.positionalParameters.some((param, i, { length }) => param.array && i < length - 1)) {
-        return { success: false, error: `Array positional parameters must be at the end of the input.` };
-    }
-    if (inner.success) {
-        const optionsProps = schemaDefPropValue(inner.value.optionsJsonSchema, 'properties');
-        if (optionsProps) {
-            const optionishPositionals = Object.entries(optionsProps).flatMap(([key, schema]) => {
-                if (typeof schema === 'object' && 'positional' in schema && schema.positional === true) {
-                    return [{ key, schema }];
-                }
-                return [];
-            });
-            if (optionishPositionals.length > 0) {
-                return {
-                    success: true,
-                    value: {
-                        positionalParameters: [
-                            ...inner.value.positionalParameters,
-                            ...optionishPositionals.map(({ key, schema }) => ({
-                                name: key,
-                                array: looksLikeArray(schema),
-                                description: schema.description ?? '',
-                                required: !isOptional(schema),
-                                type: (0, json_schema_1.getSchemaTypes)(schema).join(' | '),
-                            })),
-                        ],
-                        optionsJsonSchema: {
-                            ...inner.value.optionsJsonSchema,
-                            properties: Object.fromEntries(Object.entries(optionsProps).filter(([key]) => !optionishPositionals.some(x => x.key === key))),
-                        },
-                        getPojoInput: params => {
-                            const positionalValues = [...params.positionalValues];
-                            const options = { ...params.options };
-                            for (const { key, schema } of optionishPositionals) {
-                                options[key] = convertPositional(schema, positionalValues.shift());
-                            }
-                            return inner.value.getPojoInput({ positionalValues, options });
-                        },
-                    },
-                };
-            }
-        }
-    }
-    return inner;
-}
-function parseProcedureInputsInner(inputs, dependencies) {
-    if (inputs.length === 0) {
+  const inner = parseProcedureInputsInner(inputs, dependencies);
+  if (
+    inner.success &&
+    inner.value.positionalParameters.some(
+      (param, i, { length }) => param.array && i < length - 1,
+    )
+  ) {
+    return {
+      success: false,
+      error: `Array positional parameters must be at the end of the input.`,
+    };
+  }
+  if (inner.success) {
+    const optionsProps = schemaDefPropValue(
+      inner.value.optionsJsonSchema,
+      "properties",
+    );
+    if (optionsProps) {
+      const optionishPositionals = Object.entries(optionsProps).flatMap(
+        ([key, schema]) => {
+          if (
+            typeof schema === "object" &&
+            "positional" in schema &&
+            schema.positional === true
+          ) {
+            return [{ key, schema }];
+          }
+          return [];
+        },
+      );
+      if (optionishPositionals.length > 0) {
         return {
-            success: true,
-            value: {
-                positionalParameters: [],
-                optionsJsonSchema: {},
-                getPojoInput: () => ({}),
+          success: true,
+          value: {
+            positionalParameters: [
+              ...inner.value.positionalParameters,
+              ...optionishPositionals.map(({ key, schema }) => ({
+                name: key,
+                array: looksLikeArray(schema),
+                description: schema.description ?? "",
+                required: !isOptional(schema),
+                type: (0, json_schema_1.getSchemaTypes)(schema).join(" | "),
+              })),
+            ],
+            optionsJsonSchema: {
+              ...inner.value.optionsJsonSchema,
+              properties: Object.fromEntries(
+                Object.entries(optionsProps).filter(
+                  ([key]) => !optionishPositionals.some((x) => x.key === key),
+                ),
+              ),
             },
+            getPojoInput: (params) => {
+              const positionalValues = [...params.positionalValues];
+              const options = { ...params.options };
+              for (const { key, schema } of optionishPositionals) {
+                options[key] = convertPositional(
+                  schema,
+                  positionalValues.shift(),
+                );
+              }
+              return inner.value.getPojoInput({ positionalValues, options });
+            },
+          },
         };
+      }
     }
-    const allJsonSchemaable = inputs.every(input => looksJsonSchemaable(input));
-    if (!allJsonSchemaable) {
-        return {
-            success: false,
-            error: `Invalid input type ${inputs.map(s => s?.constructor.name).join(', ')}, only inputs that can be converted to JSON Schema are supported`,
-        };
-    }
-    if (inputs.length > 1) {
-        return parseMultiInputs(inputs, dependencies);
-    }
-    const mergedSchemaResult = toJsonSchema(inputs[0], dependencies);
-    if (!mergedSchemaResult.success) {
-        return {
-            success: false,
-            error: mergedSchemaResult.error,
-        };
-    }
-    const mergedSchema = mergedSchemaResult.value;
-    return handleMergedSchema(mergedSchema);
+  }
+  return inner;
+}
+function parseProcedureInputsInner(inputs, dependencies) {
+  if (inputs.length === 0) {
+    return {
+      success: true,
+      value: {
+        positionalParameters: [],
+        optionsJsonSchema: {},
+        getPojoInput: () => ({}),
+      },
+    };
+  }
+  const allJsonSchemaable = inputs.every((input) => looksJsonSchemaable(input));
+  if (!allJsonSchemaable) {
+    return {
+      success: false,
+      error: `Invalid input type ${inputs.map((s) => s?.constructor.name).join(", ")}, only inputs that can be converted to JSON Schema are supported`,
+    };
+  }
+  if (inputs.length > 1) {
+    return parseMultiInputs(inputs, dependencies);
+  }
+  const mergedSchemaResult = toJsonSchema(inputs[0], dependencies);
+  if (!mergedSchemaResult.success) {
+    return {
+      success: false,
+      error: mergedSchemaResult.error,
+    };
+  }
+  const mergedSchema = mergedSchemaResult.value;
+  return handleMergedSchema(mergedSchema);
 }
 function handleMergedSchema(mergedSchema) {
-    if (mergedSchema.additionalProperties) {
-        return { success: false, error: `Inputs with additional properties are not currently supported` };
-    }
-    if (acceptedPrimitiveTypes(mergedSchema).length > 0) {
-        return parsePrimitiveInput(mergedSchema);
-    }
-    if (isTuple(mergedSchema)) {
-        return parseTupleInput(mergedSchema);
-    }
-    if (mergedSchema.type === 'array') {
-        return parseArrayInput(mergedSchema);
-    }
-    if (mergedSchema.anyOf) {
-        const allObjects = mergedSchema.anyOf.every(sub => acceptsObject(toRoughJsonSchema7(sub)));
-        if (allObjects) {
-            return {
-                success: true,
-                value: {
-                    positionalParameters: [],
-                    optionsJsonSchema: mergedSchema,
-                    getPojoInput: argv => argv.options,
-                },
-            };
-        }
-        if (mergedSchema.anyOf.length === 2 && JSON.stringify(mergedSchema.anyOf[0]) === '{"not":{}}') {
-            return handleMergedSchema(mergedSchema.anyOf[1]);
-        }
-    }
-    if (mergedSchema.type !== 'object') {
-        return {
-            success: false,
-            error: `Invalid input type ${(0, util_1.inspect)(mergedSchema, { depth: 2, breakLength: Infinity })}, expected object or tuple.`,
-        };
-    }
+  if (mergedSchema.additionalProperties) {
     return {
+      success: false,
+      error: `Inputs with additional properties are not currently supported`,
+    };
+  }
+  if (acceptedPrimitiveTypes(mergedSchema).length > 0) {
+    return parsePrimitiveInput(mergedSchema);
+  }
+  if (isTuple(mergedSchema)) {
+    return parseTupleInput(mergedSchema);
+  }
+  if (mergedSchema.type === "array") {
+    return parseArrayInput(mergedSchema);
+  }
+  if (mergedSchema.anyOf) {
+    const allObjects = mergedSchema.anyOf.every((sub) =>
+      acceptsObject(toRoughJsonSchema7(sub)),
+    );
+    if (allObjects) {
+      return {
         success: true,
         value: {
-            positionalParameters: [],
-            optionsJsonSchema: mergedSchema,
-            getPojoInput: argv => argv.options,
+          positionalParameters: [],
+          optionsJsonSchema: mergedSchema,
+          getPojoInput: (argv) => argv.options,
         },
+      };
+    }
+    if (
+      mergedSchema.anyOf.length === 2 &&
+      JSON.stringify(mergedSchema.anyOf[0]) === '{"not":{}}'
+    ) {
+      return handleMergedSchema(mergedSchema.anyOf[1]);
+    }
+  }
+  if (mergedSchema.type !== "object") {
+    return {
+      success: false,
+      error: `Invalid input type ${(0, util_1.inspect)(mergedSchema, { depth: 2, breakLength: Infinity })}, expected object or tuple.`,
     };
+  }
+  return {
+    success: true,
+    value: {
+      positionalParameters: [],
+      optionsJsonSchema: mergedSchema,
+      getPojoInput: (argv) => argv.options,
+    },
+  };
 }
 // zod-to-json-schema turns `z.string().optional()` into `{"anyOf":[{"not":{}},{"type":"string"}]}`
 function isOptional(schema) {
-    if (schema && typeof schema === 'object' && 'optional' in schema)
-        return schema.optional === true;
-    if (schemaDefPropValue(schema, 'not') && JSON.stringify(schema) === '{"not":{}}')
-        return true;
-    const anyOf = schemaDefPropValue(schema, 'anyOf');
-    if (anyOf?.some(sub => isOptional(sub)))
-        return true;
-    if (schemaDefPropValue(schema, 'default') !== undefined)
-        return true;
-    return false;
+  if (schema && typeof schema === "object" && "optional" in schema)
+    return schema.optional === true;
+  if (
+    schemaDefPropValue(schema, "not") &&
+    JSON.stringify(schema) === '{"not":{}}'
+  )
+    return true;
+  const anyOf = schemaDefPropValue(schema, "anyOf");
+  if (anyOf?.some((sub) => isOptional(sub))) return true;
+  if (schemaDefPropValue(schema, "default") !== undefined) return true;
+  return false;
 }
 function parsePrimitiveInput(schema) {
-    const typeName = acceptedPrimitiveTypes(schema).join(' | ');
-    const name = (schema.title || schema.description || /\W/.test(typeName) ? 'value' : typeName).replaceAll(/\s+/g, '_');
-    return {
-        success: true,
-        value: {
-            positionalParameters: [
-                {
-                    name,
-                    array: false,
-                    description: schema.description || '',
-                    required: !isOptional(schema),
-                    type: typeName,
-                },
-            ],
-            optionsJsonSchema: {},
-            getPojoInput: argv => convertPositional(schema, argv.positionalValues[0]),
+  const typeName = acceptedPrimitiveTypes(schema).join(" | ");
+  const name = (
+    schema.title || schema.description || /\W/.test(typeName)
+      ? "value"
+      : typeName
+  ).replaceAll(/\s+/g, "_");
+  return {
+    success: true,
+    value: {
+      positionalParameters: [
+        {
+          name,
+          array: false,
+          description: schema.description || "",
+          required: !isOptional(schema),
+          type: typeName,
         },
-    };
+      ],
+      optionsJsonSchema: {},
+      getPojoInput: (argv) =>
+        convertPositional(schema, argv.positionalValues[0]),
+    },
+  };
 }
 const schemaDefPropValue = (schema, prop) => {
-    if (schema && typeof schema === 'object' && prop in schema)
-        return schema[prop];
-    return undefined;
+  if (schema && typeof schema === "object" && prop in schema)
+    return schema[prop];
+  return undefined;
 };
-const primitiveCandidateTypes = ['string', 'number', 'boolean', 'integer'];
+const primitiveCandidateTypes = ["string", "number", "boolean", "integer"];
 function acceptedPrimitiveTypes(schema) {
-    let constVals = [toRoughJsonSchema7(schema).const, toRoughJsonSchema7(schema).enum]
-        .flat()
-        .filter(Boolean)
-        .map(s => typeof s);
-    if (constVals.length === 0)
-        constVals = undefined;
-    const typeList = constVals ||
-        schemaDefPropValue(schema, 'type') ||
-        schemaDefPropValue(schema, 'oneOf')?.flatMap(s => acceptedPrimitiveTypes(s)) ||
-        schemaDefPropValue(schema, 'anyOf')?.flatMap(s => acceptedPrimitiveTypes(s));
-    const acceptedJsonSchemaTypes = new Set([typeList].flat().filter(Boolean));
-    return primitiveCandidateTypes.filter(c => acceptedJsonSchemaTypes.has(c));
+  let constVals = [
+    toRoughJsonSchema7(schema).const,
+    toRoughJsonSchema7(schema).enum,
+  ]
+    .flat()
+    .filter(Boolean)
+    .map((s) => typeof s);
+  if (constVals.length === 0) constVals = undefined;
+  const typeList =
+    constVals ||
+    schemaDefPropValue(schema, "type") ||
+    schemaDefPropValue(schema, "oneOf")?.flatMap((s) =>
+      acceptedPrimitiveTypes(s),
+    ) ||
+    schemaDefPropValue(schema, "anyOf")?.flatMap((s) =>
+      acceptedPrimitiveTypes(s),
+    );
+  const acceptedJsonSchemaTypes = new Set([typeList].flat().filter(Boolean));
+  return primitiveCandidateTypes.filter((c) => acceptedJsonSchemaTypes.has(c));
 }
 /**
  * From a list of schemas, if they are all record-style schemas, return a single schema with all properties (an intersection).
  * Returns `null` if the schemas are not all record-style schemas.
  */
 function maybeMergeObjectSchemas(schemas) {
-    const required = [];
-    const properties = {};
-    for (const schema of schemas) {
-        if (!schema)
-            return null;
-        const { required: schemaRequired, properties: schemaProperties, type, $schema, ...rest } = schema;
-        if (type && type !== 'object')
-            return null;
-        if (Object.keys(rest).length)
-            return null;
-        if (schemaRequired)
-            required.push(...schemaRequired);
-        if (schemaProperties)
-            Object.assign(properties, schemaProperties);
-    }
-    return { type: 'object', required, properties };
+  const required = [];
+  const properties = {};
+  for (const schema of schemas) {
+    if (!schema) return null;
+    const {
+      required: schemaRequired,
+      properties: schemaProperties,
+      type,
+      $schema,
+      ...rest
+    } = schema;
+    if (type && type !== "object") return null;
+    if (Object.keys(rest).length) return null;
+    if (schemaRequired) required.push(...schemaRequired);
+    if (schemaProperties) Object.assign(properties, schemaProperties);
+  }
+  return { type: "object", required, properties };
 }
 function parseMultiInputs(inputs, dependencies) {
-    const parsedIndividually = inputs.map(input => parseProcedureInputsInner([input], dependencies));
-    const failures = parsedIndividually.flatMap(p => (p.success ? [] : [p.error]));
-    if (failures.length > 0) {
-        return { success: false, error: failures.join('\n') };
-    }
-    const allObjects = parsedIndividually.every(p => p.success && p.value.positionalParameters.length === 0);
-    if (!allObjects) {
-        return {
-            success: false,
-            error: `Can't use positional parameters with multi-input type.`,
-        };
-    }
-    const merged = maybeMergeObjectSchemas(parsedIndividually.map(p => (p.success ? p.value.optionsJsonSchema : {})));
-    if (merged) {
-        return {
-            success: true,
-            value: {
-                positionalParameters: [],
-                optionsJsonSchema: merged,
-                getPojoInput: argv => argv.options,
-            },
-        };
-    }
+  const parsedIndividually = inputs.map((input) =>
+    parseProcedureInputsInner([input], dependencies),
+  );
+  const failures = parsedIndividually.flatMap((p) =>
+    p.success ? [] : [p.error],
+  );
+  if (failures.length > 0) {
+    return { success: false, error: failures.join("\n") };
+  }
+  const allObjects = parsedIndividually.every(
+    (p) => p.success && p.value.positionalParameters.length === 0,
+  );
+  if (!allObjects) {
     return {
-        success: true,
-        value: {
-            positionalParameters: [],
-            optionsJsonSchema: {
-                allOf: parsedIndividually.map(p => {
-                    const successful = p;
-                    const optionsSchema = successful.value.optionsJsonSchema;
-                    if ('additionalProperties' in optionsSchema && optionsSchema.additionalProperties === false) {
-                        const { additionalProperties, ...rest } = optionsSchema;
-                        return rest;
-                    }
-                    return optionsSchema;
-                }),
-            },
-            getPojoInput: argv => argv.options,
-        },
+      success: false,
+      error: `Can't use positional parameters with multi-input type.`,
+    };
+  }
+  const merged = maybeMergeObjectSchemas(
+    parsedIndividually.map((p) => (p.success ? p.value.optionsJsonSchema : {})),
+  );
+  if (merged) {
+    return {
+      success: true,
+      value: {
+        positionalParameters: [],
+        optionsJsonSchema: merged,
+        getPojoInput: (argv) => argv.options,
+      },
     };
+  }
+  return {
+    success: true,
+    value: {
+      positionalParameters: [],
+      optionsJsonSchema: {
+        allOf: parsedIndividually.map((p) => {
+          const successful = p;
+          const optionsSchema = successful.value.optionsJsonSchema;
+          if (
+            "additionalProperties" in optionsSchema &&
+            optionsSchema.additionalProperties === false
+          ) {
+            const { additionalProperties, ...rest } = optionsSchema;
+            return rest;
+          }
+          return optionsSchema;
+        }),
+      },
+      getPojoInput: (argv) => argv.options,
+    },
+  };
 }
 function isNullable(schema) {
-    if (Array.isArray(schema.type) && schema.type.includes('null'))
-        return true;
-    if (schema.type === 'null')
-        return true;
-    if ((schema.anyOf || schema.oneOf)?.some(sub => isNullable(toRoughJsonSchema7(sub))))
-        return true;
-    if (schema.const === null)
-        return true;
-    return false;
+  if (Array.isArray(schema.type) && schema.type.includes("null")) return true;
+  if (schema.type === "null") return true;
+  if (
+    (schema.anyOf || schema.oneOf)?.some((sub) =>
+      isNullable(toRoughJsonSchema7(sub)),
+    )
+  )
+    return true;
+  if (schema.const === null) return true;
+  return false;
 }
 const tupleItemsSchemas = (schema) => {
-    if (!schema || typeof schema !== 'object')
-        return undefined;
-    if (Array.isArray(schema.items))
-        return schema.items;
-    if ('prefixItems' in schema && Array.isArray(schema.prefixItems))
-        return schema.prefixItems;
-    return undefined;
+  if (!schema || typeof schema !== "object") return undefined;
+  if (Array.isArray(schema.items)) return schema.items;
+  if ("prefixItems" in schema && Array.isArray(schema.prefixItems))
+    return schema.prefixItems;
+  return undefined;
 };
 function isTuple(schema) {
-    return Array.isArray(tupleItemsSchemas(schema));
+  return Array.isArray(tupleItemsSchemas(schema));
 }
 function parseArrayInput(array) {
-    if (looksLikeJsonSchema(array.items) && isNullable(array.items)) {
-        return {
-            success: false,
-            error: `Invalid input type Array<${(0, json_schema_1.getSchemaTypes)(array.items).join(' | ')}>. Nullable arrays are not supported.`,
-        };
-    }
+  if (looksLikeJsonSchema(array.items) && isNullable(array.items)) {
     return {
-        success: true,
-        value: {
-            positionalParameters: [
-                {
-                    name: parameterName(array, 1),
-                    array: true,
-                    description: array.description || '',
-                    required: !isOptional(array),
-                    type: 'string',
-                },
-            ],
-            optionsJsonSchema: {},
-            getPojoInput: argv => argv.positionalValues.at(-1).map(s => convertPositional(array.items, s)),
-        },
+      success: false,
+      error: `Invalid input type Array<${(0, json_schema_1.getSchemaTypes)(array.items).join(" | ")}>. Nullable arrays are not supported.`,
     };
+  }
+  return {
+    success: true,
+    value: {
+      positionalParameters: [
+        {
+          name: parameterName(array, 1),
+          array: true,
+          description: array.description || "",
+          required: !isOptional(array),
+          type: "string",
+        },
+      ],
+      optionsJsonSchema: {},
+      getPojoInput: (argv) =>
+        argv.positionalValues
+          .at(-1)
+          .map((s) => convertPositional(array.items, s)),
+    },
+  };
 }
 function parseTupleInput(tuple) {
-    const items = tupleItemsSchemas(tuple);
-    if (!Array.isArray(items))
-        throw new Error('.items is not an array, is this really a tuple?');
-    const flagsSchemaIndex = items.findIndex(item => {
-        if (acceptedPrimitiveTypes(item).length > 0) {
-            return false; // it's a string, number or boolean
-        }
-        if (looksLikeArray(item) && acceptedPrimitiveTypes(item.items).length > 0) {
-            return false; // it's an array of strings, numbers or booleans
-        }
-        return true; // it's not a string, number, boolean or array of strings, numbers or booleans. So it's probably a flags object
-    });
-    const types = `[${items.map(s => schemaDefPropValue(s, 'type')).join(', ')}]`;
-    if (flagsSchemaIndex > -1 && flagsSchemaIndex !== items.length - 1) {
-        return {
-            success: false,
-            error: `Invalid input type ${types}. Positional parameters must be strings, numbers or booleans.`,
-        };
+  const items = tupleItemsSchemas(tuple);
+  if (!Array.isArray(items))
+    throw new Error(".items is not an array, is this really a tuple?");
+  const flagsSchemaIndex = items.findIndex((item) => {
+    if (acceptedPrimitiveTypes(item).length > 0) {
+      return false; // it's a string, number or boolean
     }
-    const flagsSchema = flagsSchemaIndex === -1 ? null : items[flagsSchemaIndex];
-    if (flagsSchema && !acceptsObject(flagsSchema)) {
-        return {
-            success: false,
-            error: `Invalid input type ${types}. The last type must accept object inputs.`,
-        };
+    if (looksLikeArray(item) && acceptedPrimitiveTypes(item.items).length > 0) {
+      return false; // it's an array of strings, numbers or booleans
     }
-    const positionalSchemas = flagsSchemaIndex === -1 ? items : items.slice(0, flagsSchemaIndex);
+    return true; // it's not a string, number, boolean or array of strings, numbers or booleans. So it's probably a flags object
+  });
+  const types = `[${items.map((s) => schemaDefPropValue(s, "type")).join(", ")}]`;
+  if (flagsSchemaIndex > -1 && flagsSchemaIndex !== items.length - 1) {
     return {
-        success: true,
-        value: {
-            positionalParameters: positionalSchemas.map((schema, i) => ({
-                name: parameterName(schema, i + 1),
-                array: looksLikeArray(schema),
-                description: schemaDefPropValue(schema, 'description') || '',
-                required: !isOptional(schema),
-                type: (0, json_schema_1.getSchemaTypes)(toRoughJsonSchema7(schema)).join(' | '),
-            })),
-            optionsJsonSchema: flagsSchema && typeof flagsSchema === 'object' ? flagsSchema : {},
-            getPojoInput: commandArgs => {
-                const inputs = commandArgs.positionalValues.map((v, i) => {
-                    const correspondingSchema = positionalSchemas[i];
-                    if (looksLikeArray(correspondingSchema)) {
-                        if (!Array.isArray(v)) {
-                            throw new errors_1.CliValidationError(`Expected array at position ${i}, got ${typeof v}`);
-                        }
-                        return v.map(s => {
-                            if (!correspondingSchema.items || Array.isArray(correspondingSchema.items))
-                                return s;
-                            return convertPositional(correspondingSchema.items, s);
-                        });
-                    }
-                    if (typeof v !== 'string' && v !== undefined) {
-                        throw new errors_1.CliValidationError(`Expected string at position ${i}, got ${typeof v}`);
-                    }
-                    return convertPositional(correspondingSchema, v);
-                });
-                if (flagsSchema) {
-                    inputs.push(commandArgs.options);
-                }
-                return inputs;
-            },
-        },
+      success: false,
+      error: `Invalid input type ${types}. Positional parameters must be strings, numbers or booleans.`,
+    };
+  }
+  const flagsSchema = flagsSchemaIndex === -1 ? null : items[flagsSchemaIndex];
+  if (flagsSchema && !acceptsObject(flagsSchema)) {
+    return {
+      success: false,
+      error: `Invalid input type ${types}. The last type must accept object inputs.`,
     };
+  }
+  const positionalSchemas =
+    flagsSchemaIndex === -1 ? items : items.slice(0, flagsSchemaIndex);
+  return {
+    success: true,
+    value: {
+      positionalParameters: positionalSchemas.map((schema, i) => ({
+        name: parameterName(schema, i + 1),
+        array: looksLikeArray(schema),
+        description: schemaDefPropValue(schema, "description") || "",
+        required: !isOptional(schema),
+        type: (0, json_schema_1.getSchemaTypes)(
+          toRoughJsonSchema7(schema),
+        ).join(" | "),
+      })),
+      optionsJsonSchema:
+        flagsSchema && typeof flagsSchema === "object" ? flagsSchema : {},
+      getPojoInput: (commandArgs) => {
+        const inputs = commandArgs.positionalValues.map((v, i) => {
+          const correspondingSchema = positionalSchemas[i];
+          if (looksLikeArray(correspondingSchema)) {
+            if (!Array.isArray(v)) {
+              throw new errors_1.CliValidationError(
+                `Expected array at position ${i}, got ${typeof v}`,
+              );
+            }
+            return v.map((s) => {
+              if (
+                !correspondingSchema.items ||
+                Array.isArray(correspondingSchema.items)
+              )
+                return s;
+              return convertPositional(correspondingSchema.items, s);
+            });
+          }
+          if (typeof v !== "string" && v !== undefined) {
+            throw new errors_1.CliValidationError(
+              `Expected string at position ${i}, got ${typeof v}`,
+            );
+          }
+          return convertPositional(correspondingSchema, v);
+        });
+        if (flagsSchema) {
+          inputs.push(commandArgs.options);
+        }
+        return inputs;
+      },
+    },
+  };
 }
 /**
  * Converts a positional string to parameter into a number if the target schema accepts numbers, and the input can be parsed as a number.
@@ -430,67 +530,70 @@ function parseTupleInput(tuple) {
  * trpc will use zod to handle the validation before invoking the procedure.
  */
 const convertPositional = (schema, value) => {
-    let preprocessed = undefined;
-    const acceptedTypes = new Set(acceptedPrimitiveTypes(schema));
-    if (acceptedTypes.has('string')) {
-        preprocessed = value;
-    }
-    if (acceptedTypes.has('boolean')) {
-        if (value === 'true')
-            preprocessed = true;
-        else if (value === 'false')
-            preprocessed = false;
+  let preprocessed = undefined;
+  const acceptedTypes = new Set(acceptedPrimitiveTypes(schema));
+  if (acceptedTypes.has("string")) {
+    preprocessed = value;
+  }
+  if (acceptedTypes.has("boolean")) {
+    if (value === "true") preprocessed = true;
+    else if (value === "false") preprocessed = false;
+  }
+  if (acceptedTypes.has("number")) {
+    const number = Number(value);
+    if (!Number.isNaN(number)) {
+      preprocessed = number;
     }
-    if (acceptedTypes.has('number')) {
-        const number = Number(value);
-        if (!Number.isNaN(number)) {
-            preprocessed = number;
-        }
-    }
-    if (acceptedTypes.has('integer')) {
-        const num = Number(value);
-        if (Number.isInteger(num)) {
-            preprocessed = num;
-        }
-        else if (!Number.isNaN(num) && acceptedTypes === undefined) {
-            // we're expecting an integer and the value isn't one, but we haven't come up with anything else, so use it anyway to get helpful "expected integer, got float" error rather than "expected number, got string"
-            preprocessed = value;
-        }
+  }
+  if (acceptedTypes.has("integer")) {
+    const num = Number(value);
+    if (Number.isInteger(num)) {
+      preprocessed = num;
+    } else if (!Number.isNaN(num) && acceptedTypes === undefined) {
+      // we're expecting an integer and the value isn't one, but we haven't come up with anything else, so use it anyway to get helpful "expected integer, got float" error rather than "expected number, got string"
+      preprocessed = value;
     }
-    if (preprocessed === undefined) {
-        return value; // we didn't convert to a number or boolean, so just return the string
-    }
-    return preprocessed;
+  }
+  if (preprocessed === undefined) {
+    return value; // we didn't convert to a number or boolean, so just return the string
+  }
+  return preprocessed;
 };
 const looksLikeArray = (schema) => {
-    return schemaDefPropValue(schema, 'type') === 'array';
+  return schemaDefPropValue(schema, "type") === "array";
 };
 const toRoughJsonSchema7 = (schema) => {
-    if (!schema || typeof schema !== 'object') {
-        return {};
-    }
-    return schema;
+  if (!schema || typeof schema !== "object") {
+    return {};
+  }
+  return schema;
 };
 const maybeParameterName = (s) => {
-    const value = schemaDefPropValue(s, 'title') || schemaDefPropValue(s, 'description');
-    // only look at array item title if we don't have one for the outer array itself
-    // e.g. for {title: 'file collection', items: {title: 'file'}} we prefer 'file collection' as the parameter name
-    if (!value && looksLikeArray(s)) {
-        const items = toRoughJsonSchema7(s).items;
-        return items && !Array.isArray(items) ? maybeParameterName(items) : undefined;
-    }
-    return value;
+  const value =
+    schemaDefPropValue(s, "title") || schemaDefPropValue(s, "description");
+  // only look at array item title if we don't have one for the outer array itself
+  // e.g. for {title: 'file collection', items: {title: 'file'}} we prefer 'file collection' as the parameter name
+  if (!value && looksLikeArray(s)) {
+    const items = toRoughJsonSchema7(s).items;
+    return items && !Array.isArray(items)
+      ? maybeParameterName(items)
+      : undefined;
+  }
+  return value;
 };
 const parameterName = (s, position) => {
-    let name = maybeParameterName(s) || `parameter_${position}`;
-    if (looksLikeArray(s))
-        return `[${name}...]`;
-    // commander requiremenets: no special characters in positional parameters; `<name>` for required and `[name]` for optional parameters
-    name = name.replaceAll(/\W+/g, ' ').trim();
-    return isOptional(s) ? `[${name}]` : `<${name}>`;
+  let name = maybeParameterName(s) || `parameter_${position}`;
+  if (looksLikeArray(s)) return `[${name}...]`;
+  // commander requiremenets: no special characters in positional parameters; `<name>` for required and `[name]` for optional parameters
+  name = name.replaceAll(/\W+/g, " ").trim();
+  return isOptional(s) ? `[${name}]` : `<${name}>`;
 };
 const acceptsObject = (schema) => {
-    return (schema.type === 'object' || schema.anyOf?.some(sub => acceptsObject(toRoughJsonSchema7(sub)))) ?? false;
+  return (
+    (schema.type === "object" ||
+      schema.anyOf?.some((sub) => acceptsObject(toRoughJsonSchema7(sub)))) ??
+    false
+  );
 };
 // #region vendor specific stuff
 /* eslint-disable @typescript-eslint/no-explicit-any */
@@ -499,100 +602,107 @@ const acceptsObject = (schema) => {
 /* eslint-disable @typescript-eslint/no-require-imports */
 /** `Record<standard-schema vendor id, function that converts the input to JSON schema>` */
 const getJsonSchemaConverters = (dependencies) => {
-    return {
-        zod: (input) => {
-            // @ts-expect-error don't worry lots of ?.
-            if (input._zod?.version?.major == 4) {
-                return zod4.toJSONSchema(input, {
-                    // todo[zod@>=4.0.0] remove the line if https://github.com/colinhacks/zod/issues/4167 is resolved, or this comment if it's closed
-                    io: 'input',
-                    // todo[zod@>=4.0.0] remove the override if https://github.com/colinhacks/zod/issues/4164 is resolved, or this comment if it's closed
-                    unrepresentable: 'any',
-                    // todo[zod@>=4.0.0] remove the override if https://github.com/colinhacks/zod/issues/4164 is resolved, or this comment if it's closed
-                    override: ctx => {
-                        if (ctx.zodSchema?.constructor?.name === 'ZodOptional') {
-                            ctx.jsonSchema.optional = true;
-                        }
-                        // this is needed because trpc-cli (currently) has its own zod dependency, which is v3, and uses zod/v4 as a submodule. But the v3 zod/v4 module drops descriptions from the produced json schema.
-                        // normally zod does this itself, but not when using v3's toJSONSchema function with a v4 schema.
-                        const meta = ctx.zodSchema.meta?.();
-                        if (meta)
-                            Object.assign(ctx.jsonSchema, meta);
-                    },
-                });
+  return {
+    zod: (input) => {
+      // @ts-expect-error don't worry lots of ?.
+      if (input._zod?.version?.major == 4) {
+        return zod4.toJSONSchema(input, {
+          // todo[zod@>=4.0.0] remove the line if https://github.com/colinhacks/zod/issues/4167 is resolved, or this comment if it's closed
+          io: "input",
+          // todo[zod@>=4.0.0] remove the override if https://github.com/colinhacks/zod/issues/4164 is resolved, or this comment if it's closed
+          unrepresentable: "any",
+          // todo[zod@>=4.0.0] remove the override if https://github.com/colinhacks/zod/issues/4164 is resolved, or this comment if it's closed
+          override: (ctx) => {
+            if (ctx.zodSchema?.constructor?.name === "ZodOptional") {
+              ctx.jsonSchema.optional = true;
             }
-            return (0, zod_to_json_schema_1.default)(input);
+            // this is needed because trpc-cli (currently) has its own zod dependency, which is v3, and uses zod/v4 as a submodule. But the v3 zod/v4 module drops descriptions from the produced json schema.
+            // normally zod does this itself, but not when using v3's toJSONSchema function with a v4 schema.
+            const meta = ctx.zodSchema.meta?.();
+            if (meta) Object.assign(ctx.jsonSchema, meta);
+          },
+        });
+      }
+      return (0, zod_to_json_schema_1.default)(input);
+    },
+    arktype: (input) => {
+      const type = prepareArktypeType(input);
+      return type.toJsonSchema({
+        fallback: (ctx) => {
+          if (ctx.code === "unit" && ctx.unit === undefined)
+            return { ...ctx.base, optional: true };
+          return ctx.base;
         },
-        arktype: (input) => {
-            const type = prepareArktypeType(input);
-            return type.toJsonSchema({
-                fallback: ctx => {
-                    if (ctx.code === 'unit' && ctx.unit === undefined)
-                        return { ...ctx.base, optional: true };
-                    return ctx.base;
-                },
-            });
-        },
-        valibot: (input) => {
-            let valibotToJsonSchemaLib = dependencies['@valibot/to-json-schema'];
-            if (!valibotToJsonSchemaLib) {
-                try {
-                    valibotToJsonSchemaLib = disguisedEval(`require('@valibot/to-json-schema')`);
-                }
-                catch (e) {
-                    throw new Error(`@valibot/to-json-schema could not be found - try installing it and re-running`, { cause: e });
-                }
-            }
-            const valibotToJsonSchema = valibotToJsonSchemaLib?.toJsonSchema;
-            if (!valibotToJsonSchema) {
-                throw new Error(`no 'toJsonSchema' function found in @valibot/to-json-schema - check you are using a supported version`);
-            }
-            let v;
-            try {
-                v = disguisedEval(`require('valibot')`);
-            }
-            catch {
-                // couldn't load valibot, maybe it's aliased to something else? anyway bad luck, you won't know about optional positional parameters, but that's a rare-ish case so not a big deal
-                return valibotToJsonSchema(input);
-            }
-            const parent = valibotToJsonSchema(v.object({ child: input }), {
-                errorMode: 'ignore',
-            });
-            const child = parent.properties.child;
-            return parent.required?.length === 0 ? Object.assign(child, { optional: true }) : child;
-        },
-        effect: (input) => {
-            const effect = dependencies.effect || disguisedEval(`require('effect')`);
-            if (!effect) {
-                throw new Error(`effect dependency could not be found - try installing it and re-running`);
-            }
-            if (!effect.Schema.isSchema(input)) {
-                const message = `input was not an effect schema - please use effect version 3.14.2 or higher. See https://github.com/mmkal/trpc-cli/pull/63`;
-                throw new Error(message);
-            }
-            return effect.JSONSchema.make(input);
-        },
-    };
+      });
+    },
+    valibot: (input) => {
+      let valibotToJsonSchemaLib = dependencies["@valibot/to-json-schema"];
+      if (!valibotToJsonSchemaLib) {
+        try {
+          valibotToJsonSchemaLib = disguisedEval(
+            `require('@valibot/to-json-schema')`,
+          );
+        } catch (e) {
+          throw new Error(
+            `@valibot/to-json-schema could not be found - try installing it and re-running`,
+            { cause: e },
+          );
+        }
+      }
+      const valibotToJsonSchema = valibotToJsonSchemaLib?.toJsonSchema;
+      if (!valibotToJsonSchema) {
+        throw new Error(
+          `no 'toJsonSchema' function found in @valibot/to-json-schema - check you are using a supported version`,
+        );
+      }
+      let v;
+      try {
+        v = disguisedEval(`require('valibot')`);
+      } catch {
+        // couldn't load valibot, maybe it's aliased to something else? anyway bad luck, you won't know about optional positional parameters, but that's a rare-ish case so not a big deal
+        return valibotToJsonSchema(input);
+      }
+      const parent = valibotToJsonSchema(v.object({ child: input }), {
+        errorMode: "ignore",
+      });
+      const child = parent.properties.child;
+      return parent.required?.length === 0
+        ? Object.assign(child, { optional: true })
+        : child;
+    },
+    effect: (input) => {
+      const effect = dependencies.effect || disguisedEval(`require('effect')`);
+      if (!effect) {
+        throw new Error(
+          `effect dependency could not be found - try installing it and re-running`,
+        );
+      }
+      if (!effect.Schema.isSchema(input)) {
+        const message = `input was not an effect schema - please use effect version 3.14.2 or higher. See https://github.com/mmkal/trpc-cli/pull/63`;
+        throw new Error(message);
+      }
+      return effect.JSONSchema.make(input);
+    },
+  };
 };
 function getVendor(schema) {
-    // note: don't check for typeof schema === 'object' because arktype schemas are functions (you call them directly instead of `.parse(...)`)
-    return schema?.['~standard']?.vendor ?? null;
+  // note: don't check for typeof schema === 'object' because arktype schemas are functions (you call them directly instead of `.parse(...)`)
+  return schema?.["~standard"]?.vendor ?? null;
 }
 const jsonSchemaVendorNames = new Set(Object.keys(getJsonSchemaConverters({})));
 function looksJsonSchemaable(value) {
-    const vendor = getVendor(value);
-    return !!vendor && jsonSchemaVendorNames.has(vendor);
+  const vendor = getVendor(value);
+  return !!vendor && jsonSchemaVendorNames.has(vendor);
 }
 function prepareArktypeType(type) {
-    let innerType = type;
-    while (innerType) {
-        if (innerType?.in && innerType.in !== innerType) {
-            innerType = innerType.in;
-        }
-        else {
-            break;
-        }
+  let innerType = type;
+  while (innerType) {
+    if (innerType?.in && innerType.in !== innerType) {
+      innerType = innerType.in;
+    } else {
+      break;
     }
-    return innerType;
+  }
+  return innerType;
 }
 // #endregion vendor specific stuff
